<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Código Avulso</title><link href="http://codigoavulso.com.br/" rel="alternate"></link><link href="http://codigoavulso.com.br/feeds/git.atom.xml" rel="self"></link><id>http://codigoavulso.com.br/</id><updated>2016-05-26T15:13:46-03:00</updated><entry><title>Como mover um subdiretório de um repositório para outro usando git</title><link href="http://codigoavulso.com.br/como-mover-um-subdiretorio-de-um-repositorio-para-outro-usando-git.html" rel="alternate"></link><published>2016-05-26T15:13:46-03:00</published><author><name>Michell Stuttgart</name></author><id>tag:codigoavulso.com.br,2016-05-26:como-mover-um-subdiretorio-de-um-repositorio-para-outro-usando-git.html</id><summary type="html">&lt;p&gt;Fala pessoal, tudo tranquilo?&lt;/p&gt;
&lt;p&gt;Meu caro leitor(a), você já passou por uma situação onde precisava transferir um diretório de um repositório para outro, sem perder o histórico de contribuições?&lt;/p&gt;
&lt;p&gt;Semanas atrás me deparei com esse desafio e achei interessante compatilhar com você a solução que encontrei.&lt;/p&gt;
&lt;h4&gt;Analisando o problema&lt;/h4&gt;
&lt;p&gt;Na situação descrita acima, a &lt;em&gt;priori&lt;/em&gt;, temos duas possíveis soluções:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Criar um novo repositório e copiar o diretório desejado do antigo repositório para o novo.&lt;/li&gt;
&lt;li&gt;Clonar o repositório original, e no repositório clonado remover todos os outros diretórios e arquivos, deixando apenas diretório desejado.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As duas opções resolvem nosso problema, porém ambas possuem alguns incovenientes.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Na &lt;em&gt;opção 1&lt;/em&gt;, o histórico de &lt;em&gt;commits&lt;/em&gt; do antigo repositório não é mantido, já que apenas o diretório é copiado. Desse modo, perdemos a lista de colaborações feitas por outros desenvolvedores, algo muito ruim.&lt;/li&gt;
&lt;li&gt;Na &lt;em&gt;opção 2&lt;/em&gt;, o histórico de &lt;em&gt;commits&lt;/em&gt; do antigo repositório é mantido, porém ele traz &lt;em&gt;commits&lt;/em&gt; de alterações de outras partes do projeto, o que não é interessante uma vez que desejamos separá-lo do seu antigo projeto.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Não seria interessante que o histórico fosse mantido, porém apenas com os &lt;em&gt;commits&lt;/em&gt; que dizem respeito ao diretório que desejamos separar do repositório original?&lt;/p&gt;
&lt;p&gt;Felizmente, o git nos fornece ferramentas que tornam isso possível.&lt;/p&gt;
&lt;h4&gt;Resolvendo o problema&lt;/h4&gt;
&lt;p&gt;Para começar, vamos supor que temos dois repositórios: &lt;em&gt;repo_novo&lt;/em&gt;, atualmente vazio e &lt;em&gt;repo_antigo&lt;/em&gt;. O &lt;em&gt;repo_antigo&lt;/em&gt; possui dois diretórios: &lt;em&gt;dirA&lt;/em&gt; e &lt;em&gt;dirB&lt;/em&gt;. Como exemplo, vamos transferir o &lt;em&gt;dirB&lt;/em&gt; do repositório &lt;em&gt;repo_antigo&lt;/em&gt; para o repositório &lt;em&gt;repo_novo&lt;/em&gt;, sem perder seu histórico de &lt;em&gt;commits&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Incialmente, vamos fazer o clone do &lt;em&gt;repo_antigo&lt;/em&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone https://github.com/nomeusuario/repo_antigo.git
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Entre dentro da pasta recém-clonada:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; repo_antigo/
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Agora vamos executar o seguinte comando:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git filter-branch --prune-empty --subdirectory-filter dirB HEAD
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;O comando acima aplica um filtro para subdiretórios (--subdirectory-filter) usando como referência o subdiretório que passamos como parâmetro (dirB) e analisando todo os histórico de &lt;em&gt;commits&lt;/em&gt; procurando por &lt;em&gt;commits&lt;/em&gt; relacionados a ele, do início do histórico até o &lt;em&gt;commit&lt;/em&gt; mais atual (HEAD).&lt;/p&gt;
&lt;p&gt;Após executar o comando, verifique o conteúdo da pasta &lt;em&gt;repo_antigo&lt;/em&gt;. Agora os únicos arquivos e diretórios presentes são os que estavam dentro do diretório &lt;em&gt;dirB&lt;/em&gt;. Se usarmos o comando &lt;code&gt;git log&lt;/code&gt;, veremos que apenas os &lt;em&gt;commits&lt;/em&gt; relacionados ao conteúdo de &lt;em&gt;dirB&lt;/em&gt; permaneceram no histórico. Vale lembrar aqui que os outros &lt;em&gt;commits&lt;/em&gt; não foram removidos do repositório remoto original, o histórico foi filtrado apenas localmente.&lt;/p&gt;
&lt;p&gt;O próximo passo agora é subir tudo isso para o &lt;em&gt;novo_repo&lt;/em&gt;. Para isso, precisamos primeiro substituir a url do &lt;em&gt;repo_antigo&lt;/em&gt; pela url do nosso &lt;em&gt;repo_novo&lt;/em&gt; e em seguida realizar o &lt;em&gt;push&lt;/em&gt;. Valçe lembrar que se seu &lt;em&gt;repo_novo&lt;/em&gt; já possuir algum &lt;em&gt;commit&lt;/em&gt; (normalmente adicionando um arquivo README.md e um arquivo LICENSE) será necessário execura um &lt;code&gt;git pull&lt;/code&gt; antes do &lt;em&gt;push&lt;/em&gt; ou sobreescrever o commit inicial do novo repositório usando &lt;code&gt;git push -f&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git remote set-url origin https://github.com/usuario/novo_repo.git
git fetch origin
git push
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Neste caso em especial, eu apenas copiei o conteúdo do diretório &lt;em&gt;dirB&lt;/em&gt; em um repositório diferente. Entretanto, a principal utilidade desse método é quando desejamos transferir o diretório para um novo repositório, sendo o mesmo posteriormente removido do repositório antigo. Porque assim, todas as novas colaborações para o conteúdo de &lt;em&gt;dirB&lt;/em&gt; devem, a partir de agora, enviadas para o &lt;em&gt;novo_repo&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Apenas para complementar o &lt;em&gt;post&lt;/em&gt;. Eu fiz uso deste método recentemente, em um dos projetos que contribuo. O repositório &lt;a href="https://github.com/daylerees/colour-schemes"&gt;colour-schemes&lt;/a&gt; possui temas de vários editores usados em desenvolvimento (Sublime Text, Atom, Kate e etc), tendo cada um seu respectivo diretório com seus temas.&lt;/p&gt;
&lt;p&gt;Sou usuário da IDE &lt;a href="https://www.jetbrains.com/pycharm/"&gt;PyCharm&lt;/a&gt;, então fiz alguns ajustes nos temas do diretório &lt;em&gt;jetbrains&lt;/em&gt; (empresa dona do &lt;a href="https://www.jetbrains.com/pycharm/"&gt;PyCharm&lt;/a&gt;) presentes nesse repositório. Foram 55 temas ajustados (me custou algumas horas de trabalho haha) mas o resultado foi muito satisfatório. Após terminar os ajustes, enviei um &lt;em&gt;pull request&lt;/em&gt; para o repositório original. Porém o que me frustrou, foi o fato dos responsáveis pelo repositório demorarem muito tempo (muito mesmo) para revisar e aprovar os &lt;em&gt;pull requests&lt;/em&gt;. Sendo assim, decidi criar um repositório contendo apenas os temas do &lt;a href="https://www.jetbrains.com/pycharm/"&gt;PyCharm&lt;/a&gt; já com minhas alterações, de modo que outros desenvolvedores pudessem usá-los. Então utilizei o método acima, clonei o meu fork do repositório original (que possuia os minhas modificações) e executei o filtro apenas para o diretório &lt;em&gt;jetbrains&lt;/em&gt;. Em seguida enviei para &lt;a href="https://github.com/mstuttgart/pycharm-colour-scheme"&gt;este meu repositório&lt;/a&gt;. Compare o conteúdo desse repositório com o meu &lt;a href="https://github.com/mstuttgart/colour-schemes/tree/feature/pycharm_themes/jetbrains"&gt;fork do repositório original&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;É isso pessoal. Espero que a dica seja útil para vocês. Qualquer dúvida é só postar nos comentários.&lt;/p&gt;
&lt;p&gt;Até o próximo tutorial.&lt;/p&gt;</summary><category term="linux"></category><category term="tutorial"></category><category term="git"></category><category term="github"></category><category term="dicas"></category></entry></feed>